在Java中，我们定义变量会申请空间来存放变量的值，而内存的容量是有限的，当一个变量值不再被引用了的时候（变为垃圾的时候），就应该将其占用的内存空间回收掉。



垃圾回收分为两个部分：判断垃圾对象和回收垃圾对象



一、如何判断对象是垃圾对象呢？

  1.引用计数法：

​    引用计数法的原理是指：给对象增加一个引用计数器，每当有一个地方引用它的时候，引用计数器+1，引用失效时，引用计数器-1，这样引用计数器为0的对象就是没有被引用的对象，即垃圾对象，Python语言就是使用的这种方法来判断垃圾对象。

  

  2.可达性分析法：

​    可达性分析法的原理是指：通过一系列称为“GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象与GC Roots没有任何引用链相连时（代表从GC Roots到这个对象不可达），证明此对象是垃圾对象，Java语言中使用的是这种方法。



![image-20210129134141459](images\image-20210129134141459.png)



如图所示，ABCD对象都可以被GC Roots引用到，而EFG对象已经无法被GC Roots引用到，所以即使FG都被E所引用，EFG对象仍然会被回收掉。



在Java中，可作为GC Roots的对象包含以下几种

1. 虚拟机栈（栈）中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈引用的对象





二、垃圾回收算法

判断出哪些对象是需要被回收的垃圾对象之后，就应该使用垃圾回收算法对这些对象进行回收，以下是常用的几种垃圾回收算法

  

1.标记-清除算法

  标记清除算法是最基础的收集算法，首先标记出所有需要回收的对象，在标记完成后统一进行回收。

![image-20210129134243719](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210129134243719.png)

如图所示，黑色的对象是需要被回收的对象，在经历过回收之后，黑色的内存空间又重新变成了可以被重新使用的内存空间。

不过标记清除算法有时间和空间上的缺点：

  1.效率问题：标记和清除两个步骤的效率都不高

  2.空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配大对象时，无法找到足够连续的内存空间，从而提前触发下一次的垃圾回收机制。



 2.标记-整理算法

  标记整理算法是在标记清除算法的基础上对空间问题进行了优化，在标记出需要被清理的对象后，不是直接对可回收对象进行清理，而是先将所有存活的对象向一端移动，然后直接清理端边界以外的内存，这样就不会再产生内存不连续的内存碎片。

![image-20210129134320243](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210129134320243.png)

3.复制算法（新生代回收算法）

  复制算法是在标记清除算法的基础上对时间问题进行了优化，它将可用内存按容量一分为二，每次只使用其中的一块。当这块内存需要进行垃圾回收的时候，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的一块内存全部清理掉。这是一种以空间换时间的算法。



介绍完了判断垃圾对象的方法和垃圾回收的算法，接下来我们来介绍垃圾回收算法的实现过程。

首先我们需要了解JVM中的内存结构

![image-20210129134345825](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210129134345825.png)

如图所示，JVM中内存大致分为栈、堆、程序计数器、本地方法栈、方法区五个部分，其中栈、程序计数器、本地方法栈都是线程独享的，也就是说每个线程都会有自己独立的这些空间，在程序运行结束后，这些区域全部被回收掉，而方法区中存放的变量一般都是永久使用的，所以垃圾回收一般发生在堆中。



堆是存放对象的区域，堆中又分为新生代和老年代两个区域，在新生代中存放的是“朝生夕死“的对象，而老年代中存放的则是不容易死去的对象。



1.新生代垃圾回收使用复制算法

  对象刚进入堆中的时候，先进入新生代的eden区域，触发新生代中的垃圾收集（Young GC）后，先把有用的对象复制到S0区域，然后清空eden区域，接下来进入堆中的对象继续进入eden区域，下一次垃圾收集时，把eden区域和S0区域中有用的对象都放入S1中，把eden和S0区域全部清空，如此往复。



2.老年代垃圾回收使用标记-整理算法

  如果新生代中的对象经过15次Young GC之后，仍然没有被回收掉，则该对象会进入老年代，老年代中的对象在垃圾回收（Full GC）时采用标记-整理算法。需要注意的一点是，老年代在进行垃圾回收时，JVM会停止运行，所以要尽可能的避免老年代垃圾回收。



由此可见，之所以新生代使用复制算法，是因为新生代中死去的对象远远多于存活下来的对象，所以复制那些有用的对象要容易的多。而老年代中大多是会存活很长时间的对象，采用复制算法会复制大量的存活对象，效率远不如标记-整理算法。

